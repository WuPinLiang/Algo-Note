# 投資遊戲

## 問題描述
給定一個長度為 `n` 的整數陣列 `v`，代表每天的投資獲利（可以是負數）。你可以在這個陣列中選擇一個連續的子區間進行投資，但你擁有 `k` 次「跳過」的機會。你可以用這些機會來跳過子區間內的某些天，以最大化你的總獲利。

目標是找到在最多 `k` 次跳過的限制下，所能獲得的最大總利潤。

## 核心解題思路
這個問題是經典「最大子陣列和」問題的延伸。由於多了「跳過 `k` 次」的維度，我們需要使用動態規劃來解決。

我們的 DP 狀態需要同時記錄目前考慮到哪個位置，以及已經使用了多少次跳過的機會。

## 動態規劃詳解

### 狀態定義
我們定義 `dp[i][j]` 為：
**考慮到第 `i` 天（即 `v[i]`），並且已經使用了 `j` 次跳過機會時，所能得到的最大利潤。**

這個定義的重點是，`dp[i][j]` 儲存的是考慮了前 `i` 個元素、用掉 `j` 次跳過機會的「全局」最佳解，而不僅僅是「以 `v[i]` 結尾」的最佳解。

### 狀態轉移
對於 `dp[i][j]`，我們可以從幾個來源轉移而來：

1.  **選擇 `v[i]`，並且不跳過它**：
    *   我們可以將 `v[i]` 接在以 `v[i-1]` 結尾的最佳子陣列後面。這種情況下的利潤是 `dp[i-1][j] + v[i]`。
    *   我們也可以選擇從 `v[i]` 開始一個全新的子陣列。這種情況下的利潤就是 `v[i]`。

2.  **選擇跳過 `v[i]`**：
    *   如果我們決定跳過 `v[i]`，那麼我們就用掉了一次跳過機會。此時的利潤與考慮到 `v[i-1]` 並且用掉 `j-1` 次跳過機會時的利潤是相同的。所以，這種情況下的利潤是 `dp[i-1][j-1]`。

綜合以上情況，`dp[i][j]` 的值應該是這三者中的最大值：
`dp[i][j] = max(dp[i-1][j] + v[i], v[i], dp[i-1][j-1])`

### 最終答案
由於最大利潤的子陣列可能在任何一天結束，並且使用任意次數（`<=k`）的跳過機會，所以最終的答案會是整個 `dp` 表格中的最大值。
`ans = max(dp[i][j])` for all `0 <= i < n` and `0 <= j <= k`。

## 程式碼
**AC 100%**
```cpp
#include <iostream>
#include <vector>
#define int long long
#define inf 1000000007

using namespace std;

inline void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> v(n);
    for(int i = 0;i < n;i++) {
        cin >> v[i];
    }

    vector<vector<int> > dp(n, vector<int> (k + 1, 0));

    for(int i = 0;i < n;i++) {
        for(int j = 0;j <= k;j++) {
            if(i - 1 >= 0)  dp[i][j] = max(dp[i][j], dp[i-1][j] + v[i]);
            if(i - 1 >= 0 and j - 1 >= 0) dp[i][j] = max(dp[i][j], dp[i-1][j-1]);
            dp[i][j] = max(dp[i][j], v[i]);
        }
    }

    int ans = -inf;

    for(int i = 0;i < n;i++) {
        for(int j = 0;j <= k;j++) {
            ans = max(ans, dp[i][j]);
        }
    }

    cout << ans << '\n';

    return ;
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    solve();
    return 0;
}
```

## 程式碼解析
*   `vector<vector<int>> dp(n, vector<int>(k + 1, 0));`: 建立一個 `n x (k+1)` 的 DP 表格，並初始化為 0。
*   **DP 迴圈**:
    *   `for(int i = 0;i < n;i++)`: 遍歷每一天。
    *   `for(int j = 0;j <= k;j++)`: 遍歷所有可能的跳過次數。
*   **狀態轉移的實現**:
    *   `if(i - 1 >= 0) dp[i][j] = max(dp[i][j], dp[i-1][j] + v[i]);`: 這對應了「延續前一天的獲利並加上今天」的情況。
    *   `if(i - 1 >= 0 and j - 1 >= 0) dp[i][j] = max(dp[i][j], dp[i-1][j-1]);`: 這對應了「跳過今天」的情況。獲利不變，但跳過次數 `j` 是從 `j-1` 來的。
    *   `dp[i][j] = max(dp[i][j], v[i]);`: 這對應了「從今天重新開始一個新的投資區間」的情況。
    *   `if` 條件確保了索引 `i-1` 和 `j-1` 不會超出邊界。
*   **尋找答案**:
    *   在填充完 `dp` 表之後，程式碼再次遍歷整個表格，以找到全局最大值 `ans`，這就是最終的答案。

## 複雜度分析
*   **時間複雜度**: O(N * K)。我們需要填充一個大小為 `n * (k+1)` 的 DP 表格，每個狀態的計算是常數時間，因此總時間複雜度為 O(N * K)。
*   **空間複雜度**: O(N * K)。主要的空間開銷來自於 `dp` 表格。